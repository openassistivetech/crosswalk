/* Software License Agreement (BSD License)
 *
 * Copyright (c) 2011, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Willow Garage, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Auto-generated by genmsg_cpp from file /home/drc/catkin_ws/src/multisense-3.1/multisense_ros/msg/DeviceInfo.msg
 *
 */


#ifndef MULTISENSE_ROS_MESSAGE_DEVICEINFO_H
#define MULTISENSE_ROS_MESSAGE_DEVICEINFO_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace multisense_ros
{
template <class ContainerAllocator>
struct DeviceInfo_
{
  typedef DeviceInfo_<ContainerAllocator> Type;

  DeviceInfo_()
    : deviceName()
    , buildDate()
    , serialNumber()
    , deviceRevision(0)
    , numberOfPcbs(0)
    , pcbSerialNumbers()
    , pcbNames()
    , imagerName()
    , imagerType(0)
    , imagerWidth(0)
    , imagerHeight(0)
    , lensName()
    , lensType(0)
    , nominalBaseline(0.0)
    , nominalFocalLength(0.0)
    , nominalRelativeAperture(0.0)
    , lightingType(0)
    , numberOfLights(0)
    , laserName()
    , laserType(0)
    , motorName()
    , motorType(0)
    , motorGearReduction(0.0)
    , apiBuildDate()
    , apiVersion(0)
    , firmwareBuildDate()
    , firmwareVersion(0)
    , bitstreamVersion(0)
    , bitstreamMagic(0)
    , fpgaDna(0)  {
    }
  DeviceInfo_(const ContainerAllocator& _alloc)
    : deviceName(_alloc)
    , buildDate(_alloc)
    , serialNumber(_alloc)
    , deviceRevision(0)
    , numberOfPcbs(0)
    , pcbSerialNumbers(_alloc)
    , pcbNames(_alloc)
    , imagerName(_alloc)
    , imagerType(0)
    , imagerWidth(0)
    , imagerHeight(0)
    , lensName(_alloc)
    , lensType(0)
    , nominalBaseline(0.0)
    , nominalFocalLength(0.0)
    , nominalRelativeAperture(0.0)
    , lightingType(0)
    , numberOfLights(0)
    , laserName(_alloc)
    , laserType(0)
    , motorName(_alloc)
    , motorType(0)
    , motorGearReduction(0.0)
    , apiBuildDate(_alloc)
    , apiVersion(0)
    , firmwareBuildDate(_alloc)
    , firmwareVersion(0)
    , bitstreamVersion(0)
    , bitstreamMagic(0)
    , fpgaDna(0)  {
    }



   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _deviceName_type;
  _deviceName_type deviceName;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _buildDate_type;
  _buildDate_type buildDate;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _serialNumber_type;
  _serialNumber_type serialNumber;

   typedef uint32_t _deviceRevision_type;
  _deviceRevision_type deviceRevision;

   typedef uint32_t _numberOfPcbs_type;
  _numberOfPcbs_type numberOfPcbs;

   typedef std::vector<uint32_t, typename ContainerAllocator::template rebind<uint32_t>::other >  _pcbSerialNumbers_type;
  _pcbSerialNumbers_type pcbSerialNumbers;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _pcbNames_type;
  _pcbNames_type pcbNames;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _imagerName_type;
  _imagerName_type imagerName;

   typedef uint32_t _imagerType_type;
  _imagerType_type imagerType;

   typedef uint32_t _imagerWidth_type;
  _imagerWidth_type imagerWidth;

   typedef uint32_t _imagerHeight_type;
  _imagerHeight_type imagerHeight;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lensName_type;
  _lensName_type lensName;

   typedef uint32_t _lensType_type;
  _lensType_type lensType;

   typedef float _nominalBaseline_type;
  _nominalBaseline_type nominalBaseline;

   typedef float _nominalFocalLength_type;
  _nominalFocalLength_type nominalFocalLength;

   typedef float _nominalRelativeAperture_type;
  _nominalRelativeAperture_type nominalRelativeAperture;

   typedef uint32_t _lightingType_type;
  _lightingType_type lightingType;

   typedef uint32_t _numberOfLights_type;
  _numberOfLights_type numberOfLights;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _laserName_type;
  _laserName_type laserName;

   typedef uint32_t _laserType_type;
  _laserType_type laserType;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _motorName_type;
  _motorName_type motorName;

   typedef uint32_t _motorType_type;
  _motorType_type motorType;

   typedef float _motorGearReduction_type;
  _motorGearReduction_type motorGearReduction;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _apiBuildDate_type;
  _apiBuildDate_type apiBuildDate;

   typedef uint16_t _apiVersion_type;
  _apiVersion_type apiVersion;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _firmwareBuildDate_type;
  _firmwareBuildDate_type firmwareBuildDate;

   typedef uint16_t _firmwareVersion_type;
  _firmwareVersion_type firmwareVersion;

   typedef uint64_t _bitstreamVersion_type;
  _bitstreamVersion_type bitstreamVersion;

   typedef uint64_t _bitstreamMagic_type;
  _bitstreamMagic_type bitstreamMagic;

   typedef uint64_t _fpgaDna_type;
  _fpgaDna_type fpgaDna;




  typedef boost::shared_ptr< ::multisense_ros::DeviceInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::multisense_ros::DeviceInfo_<ContainerAllocator> const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;

}; // struct DeviceInfo_

typedef ::multisense_ros::DeviceInfo_<std::allocator<void> > DeviceInfo;

typedef boost::shared_ptr< ::multisense_ros::DeviceInfo > DeviceInfoPtr;
typedef boost::shared_ptr< ::multisense_ros::DeviceInfo const> DeviceInfoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::multisense_ros::DeviceInfo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::multisense_ros::DeviceInfo_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace multisense_ros

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': False}
// {'multisense_ros': ['/home/drc/catkin_ws/src/multisense-3.1/multisense_ros/msg'], 'geometry_msgs': ['/opt/ros/groovy/share/geometry_msgs/cmake/../msg'], 'sensor_msgs': ['/opt/ros/groovy/share/sensor_msgs/cmake/../msg'], 'std_msgs': ['/opt/ros/groovy/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::multisense_ros::DeviceInfo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::multisense_ros::DeviceInfo_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::multisense_ros::DeviceInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::multisense_ros::DeviceInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::multisense_ros::DeviceInfo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::multisense_ros::DeviceInfo_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::multisense_ros::DeviceInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c6474ecff79a7f51e0a82ca43d0cf444";
  }

  static const char* value(const ::multisense_ros::DeviceInfo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc6474ecff79a7f51ULL;
  static const uint64_t static_value2 = 0xe0a82ca43d0cf444ULL;
};

template<class ContainerAllocator>
struct DataType< ::multisense_ros::DeviceInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "multisense_ros/DeviceInfo";
  }

  static const char* value(const ::multisense_ros::DeviceInfo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::multisense_ros::DeviceInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string deviceName\n\
string buildDate\n\
string serialNumber\n\
uint32 deviceRevision\n\
\n\
uint32    numberOfPcbs\n\
uint32[] pcbSerialNumbers\n\
string[] pcbNames\n\
\n\
string imagerName\n\
uint32 imagerType\n\
uint32 imagerWidth\n\
uint32 imagerHeight\n\
\n\
string lensName\n\
uint32 lensType\n\
float32 nominalBaseline\n\
float32 nominalFocalLength\n\
float32 nominalRelativeAperture\n\
\n\
uint32 lightingType\n\
uint32 numberOfLights\n\
\n\
string laserName\n\
uint32 laserType\n\
\n\
string motorName\n\
uint32 motorType\n\
float32 motorGearReduction\n\
\n\
string apiBuildDate\n\
uint16 apiVersion\n\
string firmwareBuildDate\n\
uint16 firmwareVersion\n\
\n\
uint64 bitstreamVersion\n\
uint64 bitstreamMagic\n\
uint64 fpgaDna\n\
";
  }

  static const char* value(const ::multisense_ros::DeviceInfo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::multisense_ros::DeviceInfo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.deviceName);
      stream.next(m.buildDate);
      stream.next(m.serialNumber);
      stream.next(m.deviceRevision);
      stream.next(m.numberOfPcbs);
      stream.next(m.pcbSerialNumbers);
      stream.next(m.pcbNames);
      stream.next(m.imagerName);
      stream.next(m.imagerType);
      stream.next(m.imagerWidth);
      stream.next(m.imagerHeight);
      stream.next(m.lensName);
      stream.next(m.lensType);
      stream.next(m.nominalBaseline);
      stream.next(m.nominalFocalLength);
      stream.next(m.nominalRelativeAperture);
      stream.next(m.lightingType);
      stream.next(m.numberOfLights);
      stream.next(m.laserName);
      stream.next(m.laserType);
      stream.next(m.motorName);
      stream.next(m.motorType);
      stream.next(m.motorGearReduction);
      stream.next(m.apiBuildDate);
      stream.next(m.apiVersion);
      stream.next(m.firmwareBuildDate);
      stream.next(m.firmwareVersion);
      stream.next(m.bitstreamVersion);
      stream.next(m.bitstreamMagic);
      stream.next(m.fpgaDna);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER;
  }; // struct DeviceInfo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::multisense_ros::DeviceInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::multisense_ros::DeviceInfo_<ContainerAllocator>& v)
  {
    s << indent << "deviceName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.deviceName);
    s << indent << "buildDate: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.buildDate);
    s << indent << "serialNumber: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.serialNumber);
    s << indent << "deviceRevision: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.deviceRevision);
    s << indent << "numberOfPcbs: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numberOfPcbs);
    s << indent << "pcbSerialNumbers[]" << std::endl;
    for (size_t i = 0; i < v.pcbSerialNumbers.size(); ++i)
    {
      s << indent << "  pcbSerialNumbers[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.pcbSerialNumbers[i]);
    }
    s << indent << "pcbNames[]" << std::endl;
    for (size_t i = 0; i < v.pcbNames.size(); ++i)
    {
      s << indent << "  pcbNames[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.pcbNames[i]);
    }
    s << indent << "imagerName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.imagerName);
    s << indent << "imagerType: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.imagerType);
    s << indent << "imagerWidth: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.imagerWidth);
    s << indent << "imagerHeight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.imagerHeight);
    s << indent << "lensName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lensName);
    s << indent << "lensType: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.lensType);
    s << indent << "nominalBaseline: ";
    Printer<float>::stream(s, indent + "  ", v.nominalBaseline);
    s << indent << "nominalFocalLength: ";
    Printer<float>::stream(s, indent + "  ", v.nominalFocalLength);
    s << indent << "nominalRelativeAperture: ";
    Printer<float>::stream(s, indent + "  ", v.nominalRelativeAperture);
    s << indent << "lightingType: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.lightingType);
    s << indent << "numberOfLights: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numberOfLights);
    s << indent << "laserName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.laserName);
    s << indent << "laserType: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.laserType);
    s << indent << "motorName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.motorName);
    s << indent << "motorType: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.motorType);
    s << indent << "motorGearReduction: ";
    Printer<float>::stream(s, indent + "  ", v.motorGearReduction);
    s << indent << "apiBuildDate: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.apiBuildDate);
    s << indent << "apiVersion: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.apiVersion);
    s << indent << "firmwareBuildDate: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.firmwareBuildDate);
    s << indent << "firmwareVersion: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.firmwareVersion);
    s << indent << "bitstreamVersion: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.bitstreamVersion);
    s << indent << "bitstreamMagic: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.bitstreamMagic);
    s << indent << "fpgaDna: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.fpgaDna);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MULTISENSE_ROS_MESSAGE_DEVICEINFO_H
